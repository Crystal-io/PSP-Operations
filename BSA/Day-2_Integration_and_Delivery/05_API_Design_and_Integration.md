# 05. Дизайн API и интеграции (усиленная версия)

## Цель модуля
Дать системному аналитику **пошаговый best-practice подход** к:
- описанию API как контракта (REST / JSON / Webhooks)
- проектированию интеграций между системами
- учёту NFR и эксплуатационных аспектов (timeouts, retries, idempotency, наблюдаемость)
- миграции с текущей системы на новую (cutover / dual-run / backward compatibility)
- подготовке «интервью-готовых» ответов и чек-листов

Фокус: **как делает сильный System Analyst**, чтобы разработка и QA могли реализовать и проверить без «догадок».

---

## 1. API как контракт: что это означает на практике

API — это **договор** между:

- клиентом (frontend / mobile / внешняя система)

- сервером (backend / сервис)


Контракт определяет:
- доступные операции (endpoints)

- входные данные (request)

- выходные данные (response)

- правила обработки (business rules)

- ошибки и исключения

- ограничения (rate limits, размер payload, версии)


> Сильный аналитик пишет контракт так, чтобы **его можно было тестировать**.

---

## 2. Пошаговый подход системного аналитика к описанию API

### Шаг 0. Контекст и границы
Ответь на вопросы:
- кто потребитель API (web, mobile, партнёр, внутренний сервис)?
- какие системы участвуют (System A → System B)?
- какой тип интеграции нужен (sync / async)?
- какой бизнес-результат должен быть достигнут?

**Артефакт:** короткая «Integration Overview» (1–2 абзаца).

---

### Шаг 1. Список операций (endpoints) и их назначение
Для каждой операции зафиксируй:
- имя ресурса

- действие

- метод

- краткое назначение


**Пример (CRUD + бизнес-операции):**
- `POST /payments` — создать платёж

- `GET /payments/{id}` — получить статус

- `POST /payments/{id}/cancel` — отменить


---

### Шаг 2. Модель данных (Data Contract)
Опиши:

- поля request/response

- типы данных

- обязательность

- формат (ISO 8601, currency codes)

- правила валидации


**Best practice:**
- одинаковые структуры ошибок

- единые справочники (enum)

- явное указание nullable/optional


---

### Шаг 3. Статусы и жизненный цикл сущности
Опиши state machine (простым списком или диаграммой):
- какие статусы бывают

- какие переходы допустимы

- что является «терминальным» статусом


**Пример (платёж):** `NEW → PROCESSING → SUCCESS/FAILED → REFUNDED`

---

### Шаг 4. Ошибки (Error Model) и коды
Раздели ошибки на:

1) **Validation errors** (400)

2) **Auth/Permission** (401/403)

3) **Not found** (404)

4) **Conflict** (409)

5) **Rate limit** (429)

6) **Server errors** (5xx)

7) **Business errors** (обычно 422 или 409 — по договорённости)


**Best practice для ответа ошибки:**
- `errorCode` (внутренний код)

- `message` (человеческое описание)

- `details` (поле/причина)

- `traceId` (для поддержки)


---

### Шаг 5. Идемпотентность, ретраи, таймауты
Это критично для high-load и интеграций.

**Что фиксировать в контракте:**
- идемпотентные операции (например, создание платежа)

- использование `Idempotency-Key` header

- правила обработки повторов

- таймауты клиента/сервера (ожидаемые)

- retry policy (когда можно повторять, а когда нельзя)


**Утверждение для интервью:**

> Если операция может повториться из-за сети — она должна быть идемпотентной или иметь защиту от дублей.

---

### Шаг 6. Безопасность и доступ
Обязательно описать:
- тип авторизации (API key / OAuth2 / JWT)

- обязательные headers

- подписи (HMAC) для webhook

- ограничения по IP (allowlist) при необходимости

- маскирование PII/секретов в логах


---

### Шаг 7. Наблюдаемость и эксплуатация
Сильный аналитик включает в контракт эксплуатационные штуки:
- `traceId/correlationId` в ответах

- логируемые поля

- метрики (см. ниже)

- SLA / ожидания по времени ответа


---

## 3. Метрики API и эксплуатационные показатели (что важно указывать)

### Технические метрики
- latency (p50/p95/p99)

- error rate (4xx/5xx)

- throughput (RPS)

- timeouts

- retries count


### Бизнес-метрики (пример для платежей)
- success rate

- decline rate

- conversion rate

- average processing time


**Best practice:**
Фиксировать хотя бы 3–5 ключевых метрик для фичи/интеграции.

---

## 4. Best practices по контрактам (чек-лист)

- Версионирование (`/v1/` или через header)

- Backward compatibility (не ломать старых клиентов)

- Стандартизация ошибок

- Договорённость по статусам сущностей

- Явные ограничения (rate limit, max payload)

- Документация через OpenAPI + примеры (examples)

- Описание edge cases

- Тестируемость (AC для API)


---

## 5. Интеграции: best practices и детали, которые надо учесть

### 5.1 Тип интеграции
- **Sync (REST)** — запрос-ответ

- **Async (webhook / очередь)** — событие

- **Streaming (WebSocket)** — real-time


### 5.2 Канал и надёжность
- гарантии доставки (at-least-once / at-most-once)

- порядок сообщений

- дедупликация

- DLQ / повторная обработка


### 5.3 Данные и мэппинг
- поле-to-поле мэппинг

- трансформации (валюта, timezone)

- справочники/enum

- правила округления


### 5.4 Контроль версий
- согласование изменений

- deprecation policy

- сроки поддержки старой версии


### 5.5 Тестирование интеграций
- контрактные тесты

- интеграционные стенды

- тестовые данные

- мок-сервисы


---

## 6. Миграция со старой системы на новую (интеграция + переход)

Ниже — типовой migration playbook, который ожидают от системного аналитика на уровне проработки.

### 6.1 Подготовка
- инвентаризация текущих интеграций

- описание текущего поведения (as-is)

- gap analysis (что меняется)

- план совместимости


### 6.2 Стратегии миграции
**1) Parallel run (dual-run)**

- обе системы работают параллельно

- сравниваются результаты

- безопасно, но дороже


**2) Phased rollout**

- перевод по регионам/сегментам

- быстрый контроль


**3) Big-bang cutover**

- резкий переход

- рискованно, требует сильной подготовки


### 6.3 Контроль данных
- миграция справочников

- консистентность статусов

- reconciliation (сверка результатов)


### 6.4 План отката (rollback)
- условия отката

- сроки

- что сохраняем/логируем


---

## 7. Типовые вопросы на интервью (с ответами)

**Вопрос:** Что такое API-контракт?  
**Ответ:** Это договор о формате запросов/ответов, правилах обработки, ошибках и ограничениях между системами.

**Вопрос:** Какие статус-коды вы считаете обязательными для описания?  
**Ответ:** Минимум 200/201, 400, 401/403, 404, 409, 429, 5xx + отдельная модель business ошибок.

**Вопрос:** Зачем нужна идемпотентность?  
**Ответ:** Чтобы повторные запросы из-за сети не создавали дубликаты операций и финансовых ошибок.

**Вопрос:** Какие детали вы всегда фиксируете в интеграции?  
**Ответ:** Авторизация, мэппинг данных, ошибки, таймауты/ретраи, versioning, окружения и тестовые данные.

**Вопрос:** Как вы подходите к миграции на новую систему?  
**Ответ:** Инвентаризация as-is, gap analysis, стратегия (dual-run/phase/big-bang), план сверки данных и rollback.

---

## Результат модуля

После этого модуля ты:
- умеешь описывать API как контракт

- учитываешь ошибки, NFR, ретраи и идемпотентность

- системно прорабатываешь интеграции

- понимаешь подходы к миграции и cutover

- уверенно отвечаешь на интервью по API/интеграциям


Следующий модуль:
06_Debugging_Charles_and_Logs.md
